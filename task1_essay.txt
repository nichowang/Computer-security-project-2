CSC 276 Project 2 - Task 1 Essay: Understanding Speculative Execution Based Attacks

Q1: What is speculative execution, and why do modern CPUs use it?

Speculative execution is when the CPU executes instructions before it actually knows if those instructions should run or not. The main use case is with branch instructions. When the CPU hits a branch, instead of just sitting there waiting to figure out which way to go, it makes a prediction and starts executing down that path. This keeps the pipeline busy instead of stalling. Without this, the CPU would be waiting around all the time for branches to resolve, which would tank performance. Modern branch predictors are actually pretty good - they get it right over 90% of the time by looking at historical patterns. So basically it's all about keeping the execution units busy and maximizing throughput.

Q2: How does speculative execution lead to unintended side effects?

When speculation turns out to be wrong, the CPU rolls back the architectural state - it discards those instructions and their results. But here's the problem: microarchitectural state doesn't get rolled back. Things like what's in the cache, TLB entries, branch predictor state, all of that stays modified. So even though the architectural state looks fine, there are still traces left behind in the microarchitecture. You can observe these through timing - like checking if something is cached or not based on how long it takes to access. That's how the attacks work - they measure these timing differences to figure out what memory got accessed during speculation, even though those accesses were supposed to disappear when the speculation was undone.

Q3: What makes Spectre different from Meltdown?

They exploit different things. Spectre works by messing with the branch predictor. You train it to predict a certain way, and then when you trigger a misprediction, the CPU speculatively executes code that accesses out-of-bounds memory. Meltdown is more direct - it just tries to access kernel memory from user space, and relies on the fact that during out-of-order execution, the CPU actually loads the data before it checks if you have permission to access it. So the root causes are different: Spectre is about branch misprediction causing bad speculative execution, Meltdown is about privilege checks being delayed in the out-of-order pipeline.

In terms of what boundaries they break, Meltdown is specifically about crossing the user-kernel boundary. Spectre is more flexible - it can work within the same privilege level (like leaking data between processes or breaking out of browser sandboxes) and technically can also work across privilege boundaries though that's harder to pull off. Spectre requires more setup but is more broadly applicable. Meltdown is simpler to execute but is really focused on that user-to-kernel attack.

Q4: Between Spectre and Meltdown, which one is harder to defend?

Spectre is way harder. Meltdown has a pretty straightforward fix - KPTI (Kernel Page Table Isolation). You basically separate the user and kernel page tables so even during speculation, user processes can't see kernel memory. The performance cost is something like 5-30% depending on your workload, which isn't great but it's manageable.

Spectre though, that's a mess. You need multiple layers of defense - inserting serialization instructions like lfence to stop speculation, retpolines for indirect branches, changes to compilers, modifications to hardware branch predictors. And the fundamental problem is that speculative execution itself is the issue, and that's core to how modern CPUs get their performance. You can't just turn it off or you'd lose like 50%+ performance. New Spectre variants keep getting discovered too. So Meltdown is pretty much solved with KPTI, but Spectre is still an ongoing problem.

Q5: Which CPU vendors are affected by Spectre and/or Meltdown?

Intel is affected by both. AMD has Spectre but not Meltdown - they implement privilege checking differently so they don't have that vulnerability. ARM processors are affected by both, though which specific models varies. IBM POWER chips have Spectre variants too. Basically everyone is hit by Spectre to some degree because speculative execution is such a fundamental technique. Intel got hit by both because of how they implemented their out-of-order execution. AMD avoided Meltdown because their privilege checks actually get enforced earlier in the speculative execution process.

Q6: What lessons do these attacks teach us about the trade-off between performance and security in hardware design?

The main lesson is that everyone assumed microarchitectural stuff was invisible to software, and that turned out to be completely wrong. Hardware designers spent all this time making sure architectural state was correct after speculation, but they didn't think about the microarchitectural side effects at all. These attacks showed that this abstraction between architecture and microarchitecture isn't as clean as people thought.

What surprised everyone was that these performance optimizations had been around for decades, and suddenly they could be used to leak information from billions of devices. For years the focus was just on performance, and security wasn't really considered at the microarchitectural level. The key takeaway is you can't just add security later - it has to be designed in from the start. Going forward, hardware designers need to evaluate security implications of performance features during the design phase, not after everything is already deployed. We need new ways to analyze whether a performance optimization creates security vulnerabilities before we ship it in millions of CPUs.
